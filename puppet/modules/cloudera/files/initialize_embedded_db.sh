#!/bin/bash
#
#WARNING: hive username, password and database are hardcoded (hive, hivePassword, metastore)
#
#
# (c) Copyright 2011-2012 Cloudera, Inc.
#
# This script initializes SCM and Monitoring services "embedded" database.
# This involves:
#   * Running PostgreSQL's "initdb" to create an empty database server.
#   * Updating database properties to accept connection remotely.
#   * Updating max number of connections that server can open.
#   * Starting the server.
#   * Creating empty databases for SCM, SMON, AMON, HMON, RMAN, NAV.
#   * Stopping the server.
# This is typically invoked by "service cloudera-scm-server-db".  If running
# manually, note the following environment variables:
#   PATH=/usr/lib/postgresql/9.1/bin/:$PATH \
#   UNIX_SOCKET_DIR=/var/run/cloudera-scm-server-db \
#   PG_HOST=/var/run/cloudera-scm-server-db \
#   EXTRA_PG_ARGS="-k /var/run/cloudera-scm-server-db" \
#   pkgs/cloudera-scm-server-db/initialize_embedded_db.sh /var/lib/cloudera-scm-server-db/data /var/log/cloudera-scm-server/db.log
#
# This script can be executed multiple times; if the data dir already exists, it
# will create any DBs that haven't been created before, but will not touch
# existing databases.

# This marker will be searched for to decide if this is an upgrade that requires
# modifying an existing postgresql.conf
CURRENT_VERSION_MARKER='CM_4_6'

stop_db()
{
  if [[ $DB_STARTED -eq 1 ]]; then
    pg_ctl stop -w -l "$SERVER_LOGFILE" -D "$DATA_DIR" -o "$EXTRA_PG_ARGS"
    RET=$?
    if [[ $RET -ne 0 ]]; then
      echo "Could not stop database server"
      exit $RET
    fi
  fi
}

# Display an error and either fail or continue executing.
fail_or_continue()
{
    local RET=$1
    local STR=$2

    if [[ $RET -ne 0 ]]; then
        stop_db
        if [[ -z $STR ]]; then
            STR="--> Error $RET"
        fi
        echo "$STR, giving up"
        exit $RET
    fi
}

backup_file()
{
  local FILE=$1
  if [[ -f $FILE ]] && [[ ! -f $FILE.$NOW ]]; then
    cp $FILE $FILE.$NOW
  fi
}

create_database()
{
  # Start the db if needed (-w waits for the start to finish).
  if [[ $DB_STARTED -eq 0 ]]; then
    pg_ctl start -w -l "$SERVER_LOGFILE" -D "$DATA_DIR" -o "$EXTRA_PG_ARGS"
    fail_or_continue $? "Could not start database server"
    DB_STARTED=1
  fi

  local DB_CMD="psql --host=localhost --port=$DB_PORT --username=$USER --dbname=postgres -v ON_ERROR_STOP=1"
  local DBNAME=$1
  local PW=$2
  $DB_CMD --command "CREATE ROLE $DBNAME LOGIN PASSWORD '$PW';"
  fail_or_continue $? "Unable to create database role $DBNAME"
  $DB_CMD --command "CREATE DATABASE $DBNAME OWNER $DBNAME;"
  fail_or_continue $? "Unable to create database $DBNAME"

  $DB_CMD --command "CREATE ROLE hive LOGIN PASSWORS 'hivePassword';"
  fail_or_continue $? "Unable to create role hive"
  $DB_CMD --command "CREATE DATABASE metastore OWNER hive;"
  fail_or_continue $? "Unable to create database metastore"
}

# Returns 0 if the given DB exists in the DB list file.
db_exists()
{
  grep -q -s -e "^$1$" $DB_LIST_FILE
}

create_random_password()
{
  perl -le 'print "pseudo_random_password"'
}

# Creates the SCM database, if it doesn't exist yet.
create_scm_db()
{
  if db_exists scm; then
    return 0
  fi

  echo "Creating SCM configuration file: $DB_PROP_FILE"
  backup_file $DB_PROP_FILE
  local PW=`create_random_password`
  create_database scm $PW

  orig_umask=$(umask)
  umask 0077
  cat > $DB_PROP_FILE << EOF
# Auto-generated by `basename $0`
#
# $NOW
#
# These are database settings for CM Manager
#
com.cloudera.cmf.db.type=postgresql
com.cloudera.cmf.db.host=localhost:$DB_PORT
com.cloudera.cmf.db.name=scm
com.cloudera.cmf.db.user=scm
com.cloudera.cmf.db.password=$PW
EOF

  umask $orig_umask
  fail_or_continue $? "Error creating file $DB_PROP_FILE"
  echo "Created db properties file $DB_PROP_FILE"
  backup_file $DB_LIST_FILE
  echo scm >> $DB_LIST_FILE
}

# Creates a database for a specific role, if it doesn't exist yet.
create_mgmt_role_db()
{
  # $1 is the MgmtServiceHandler.RoleNames Enum value
  # $2 is the database name.
  local role=$1
  local db=$2
  if db_exists $db; then
    return 0
  fi

  echo "Creating DB $db for role $role"
  local pw=`create_random_password`
  create_database $db $pw

  if [[ $MGMT_DB_MODIFIED -eq 0 ]]; then
    backup_file $MGMT_DB_PROP_FILE
  fi
  MGMT_DB_MODIFIED=1

  # Write the prop file header.
  if [[ ! -f $MGMT_DB_PROP_FILE ]]; then
    orig_umask=$(umask)
    umask 0077
    cat > $MGMT_DB_PROP_FILE << EOF
# Auto-generated by `basename $0`
#
# $NOW
#
# These are database settings for the
# Cloudera Manager Management Services (Full Edition only),
# and are used during the creation wizard. The source of
# record for these settings is the database.
#
EOF

    umask $orig_umask
    fail_or_continue $? "Error creating file $MGMT_DB_PROP_FILE"
  fi

  local PREFIX="com.cloudera.cmf.$role.db"

  # Append the role db properties to the mgmt db props file.
  cat >> $MGMT_DB_PROP_FILE <<EOF
$PREFIX.type=postgresql
$PREFIX.host=$DB_HOSTPORT
$PREFIX.name=$db
$PREFIX.user=$db
$PREFIX.password=$pw
EOF
  fail_or_continue $? "Error updating file $MGMT_DB_PROP_FILE"

  # Update pg_hba.conf for the new database.
  echo "host    $db   $db   0.0.0.0/0   md5" >> $DATA_DIR/pg_hba.conf

  echo "Created DB for role $role"
  backup_file $DB_LIST_FILE
  echo $db >> $DB_LIST_FILE
}

pg_hba_contains()
{
  grep -q -s -e "^$1$" $DATA_DIR/pg_hba.conf
}

# changes postgres config to allow remote connections. Idempotent.
enable_remote_connections()
{
  local FIRSTLINE="# block remote access for admin user and scm"
  local SECONDLINE="host    all    cloudera-scm,scm 0.0.0.0/0 reject"
  local THIRDLINE="# enable remote access for other users"
  local FOURTHLINE="host    sameuser all  0.0.0.0/0   md5"

  if pg_hba_contains "$FIRSTLINE"; then
    return 0
  fi
  # Update pg_hba.conf for the new database.
  echo $FIRSTLINE >> $DATA_DIR/pg_hba.conf
  echo $SECONDLINE >> $DATA_DIR/pg_hba.conf
  echo $THIRDLINE >> $DATA_DIR/pg_hba.conf
  echo $FOURTHLINE >> $DATA_DIR/pg_hba.conf

  echo "Enabled remote connections"
}
# Get the amount of RAM on the system. Uses "free -b" to get the amount
# in bytes and parses the output to get total amount of memory available.
get_system_ram()
{
  local free_output=`free -b | grep Mem`
  local regex="Mem:[[:space:]]+([[:digit:]]+)"
  if [[ $free_output =~ $regex ]]; then
    echo ${BASH_REMATCH[1]}
  else
    fail_or_continue 1 "Unable to find amount of RAM on the system"
  fi
}

# We need to set a good value for postgresql shared_buffer parameter. Default
# is 32 MB which is too low. Postgresql recommends setting this to 1/4 of RAM
# if there is more than 1GB of RAM on the system (which is true for most systems
# today). This parameter also depends on the Linux maximum shared memory parameter
# (cat /proc/sys/kernel/shmmax)
# Few linux systems default the shmmax to 32 MB, at which level we should let
# postgresql default as is. Above this value, we will use 50% of the shmmax as
# the shared_buffer default value. Also maximum recommended value is 8GB, so
# we will ceil on 8 GB.
#
# shared_buffer is specified in kernel buffer cache block size, typically
# 1024 bytes (8192 bits). So the shared_buffer value * 8192 gives the memory
# in bits that will be used (actually table 17-2 of postgresql doc says that
# it should be 8192 + 208: http://www.postgresql.org/docs/9.1/static/kernel-resources.html)
#
get_shared_buffers()
{
  local ram=$(get_system_ram)
  local shmmax=`cat /proc/sys/kernel/shmmax`
  local THIRTY_TWO_MB=$((32 * 1024 * 1024))
  local EIGHT_GB=$((8 * 1024 * 1024 * 1024))
  local SIXTEEN_GB=$((16 * 1024 * 1024 * 1024))
  local shared_buffer;

  # On some systems we get value of shmmax that is out of range for integer
  # values that bash can process (see OPSAPS-11583). So we check for any
  # value that is greater than 99 GB (length > 11) and then floor shmmax value
  # to 16 GB (as 8GB is max shared buffer value, 50% of shmmax)
  if [ ${#shmmax} -gt 11 ]; then
    shmmax=$SIXTEEN_GB
  fi

  if [ "$shmmax" -gt "$THIRTY_TWO_MB" ]; then
    let "shared_buffer=shmmax / 2"
    if [ "$shared_buffer" -gt "$EIGHT_GB" ]; then
      shared_buffer=$EIGHT_GB
    fi

        let "quarter_of_ram=ram / 4"
    if [ "$shared_buffer" -gt "$quarter_of_ram" ]; then
      shared_buffer=$quarter_of_ram
    fi

    let "shared_buffer=shared_buffer / (8192 + 208)"
    echo "shared_buffers=$shared_buffer"
  fi
}

get_postgresql_major_version()
{
  local psql_output=`psql --version`
  local regex="^psql \(PostgreSQL\) ([[:digit:]]+)\..*"

  if [[ $psql_output =~ $regex ]]; then
    echo ${BASH_REMATCH[1]}
  fi
}

get_standard_conforming_strings()
{
  local psql_version=$(get_postgresql_major_version)
  if [[ $psql_version -gt 8 ]]; then
    echo "# This is needed to make Hive work with Postgresql 9.1 and above"
    echo "# See OPSAPS-11795"
    echo "standard_conforming_strings=off"
  fi
}

configure_postgresql_conf()
{
  local CONF_FILE="$1"
  local IS_UPGRADE="$2"
  # Re-configure the listen address and port, since the postgresql-server
  # package may be using the default postgres port and listen address.
  # Though typically the default configs don't specify a
  # port, we try to remove it anyway.
  sed -e '/^port\s*=/d' -i $CONF_FILE

  # Listen on all IP addresses, as monitoring services may reside on
  # different machines on the LAN.
  sed -e '/^listen_addresses\s*=/d' -i $CONF_FILE

  # Bump up max connections to server and shared buffer space that connections
  # need. shared_buffers should be at least 2 * max_connections.
  sed -e '/^max_connections\s*=/d' -i $CONF_FILE
  sed -e '/^shared_buffers\s*=/d' -i $CONF_FILE
  sed -e '/^standard_conforming_strings\s*=/d' -i $CONF_FILE

  # Prepend to the file
  local TMPFILE=$(mktemp /tmp/XXXXXXXX)
  if [ $IS_UPGRADE -eq 0 ]; then
    cat > $TMPFILE << EOF
#########################################
# === Generated by cloudera-scm-server-db at $NOW
#########################################
EOF
  fi

  cat $CONF_FILE >> $TMPFILE

  echo Adding configs
  sed -i "2a # === $CURRENT_VERSION_MARKER at $NOW" $TMPFILE
  sed -i "3a port = $DB_PORT" $TMPFILE
  sed -i "4a listen_addresses = '*'" $TMPFILE
  sed -i "5a max_connections = 600" $TMPFILE
  sed -i "6a $(get_shared_buffers)" $TMPFILE
  local SCS="$(get_standard_conforming_strings)"
  if [ "$SCS" != "" ]; then
    sed -i "7a $(get_standard_conforming_strings)" $TMPFILE
  fi

  cat $TMPFILE > $CONF_FILE
}

cd
DB_HOST=$(hostname -f)
DB_PORT=${DB_PORT:-7432}
DB_HOSTPORT="$DB_HOST:$DB_PORT"
DB_PROP_FILE=/etc/cloudera-scm-server/db.properties
MGMT_DB_PROP_FILE=/etc/cloudera-scm-server/db.mgmt.properties

if [[ $# -ne 2 ]]; then
    echo "Usage: $0 <data_dir> <server_logfile>"
    exit 1
fi

DATA_DIR=$1
SERVER_LOGFILE=$2
DB_LIST_FILE=$DATA_DIR/scm.db.list
PASSWORD_FILE="$DATA_DIR/generated_password.txt"
NOW=$(date +%Y%m%d-%H%M%S)

# Bail out if db server is running.
if pg_ctl status -D $DATA_DIR >/dev/null 2>&1; then
  fail_or_continue 1 "Database is already running. Please stop it first."
fi

# Create the directory if it doesn't already exist
if [[ ! -d $DATA_DIR ]]; then
  install -m 700 -d $DATA_DIR
  fail_or_continue $? "Could not create $DATA_DIR"
fi
# If the data dir is empty, initialize it.
if [[ -z `find "$DATA_DIR" -maxdepth 0 -not -empty 2>/dev/null` ]]; then
  PASSWORD=`create_random_password`
  PASSWORD_TMP_FILE=$(mktemp /tmp/XXXXXXXX)
  cat > $PASSWORD_TMP_FILE <<EOF
$PASSWORD

The password above was generated by $0 (part of the cloudera-manager-server-db package)
and is the password for the user 'cloudera-scm' for the database in the current directory.

Generated at $NOW.
EOF

  initdb --pgdata "$DATA_DIR" --encoding=UTF8 --locale=en_US.UTF8 --auth=md5 --username="$USER" --pwfile="$PASSWORD_TMP_FILE"
  fail_or_continue $? "Could not initialize database server.
  This usually means that your PostgreSQL installation failed or isn't working properly.
  PostgreSQL is installed using the set of repositories found on this machine. Please
  ensure that PostgreSQL can be installed. Please also uninstall any other instances of
  PostgreSQL and then try again."

  # We save the password so that the database is re-usable later.
  # Note that we couldn't create this file initially, because initdb
  # requires an empty directory to work in.
  install -m 0600 $PASSWORD_TMP_FILE $PASSWORD_FILE

  # Make necessary changes to postgresql.conf
  configure_postgresql_conf $DATA_DIR/postgresql.conf 0

  # Add header to pg_hba.conf.
  echo "# Accept connections from all hosts" >> $DATA_DIR/pg_hba.conf
else
  # If the DB already exists, we need to verify the existing data. Load the
  # password file, and if a DB list file does not exist, check DB_PROP_FILE
  # and MGMT_DB_PROP_FILE for existing databases.
  PASSWORD=$(head -n 1 $PASSWORD_FILE)
  if [[ ! -f $DB_LIST_FILE ]]; then
    for pfile in $DB_PROP_FILE $MGMT_DB_PROP_FILE; do
      if [[ -f $pfile ]]; then
        grep \\.name= $pfile | awk -F= '{ print $2 }' >> $DB_LIST_FILE
      fi
    done
  fi

  # Re-write postgresql.conf when upgrading, to ensure new settings are present.
  grep -q $CURRENT_VERSION_MARKER $DATA_DIR/postgresql.conf
  if [ $? -ne 0 ]; then
    cp --backup=numbered $DATA_DIR/postgresql.conf $DATA_DIR/postgresql.conf.orig
    configure_postgresql_conf $DATA_DIR/postgresql.conf 1
  fi
fi

# Create the scm and role databases, if needed.
DB_STARTED=0
MGMT_DB_MODIFIED=0
export PGPASSWORD=$PASSWORD
create_scm_db
create_mgmt_role_db SERVICEMONITOR smon
create_mgmt_role_db ACTIVITYMONITOR amon
create_mgmt_role_db HOSTMONITOR hmon
create_mgmt_role_db REPORTSMANAGER rman
create_mgmt_role_db NAVIGATOR nav
# with dynamic db creation, no need to call "create_mgmt_role_db" for new roles
# above calls kept for consistency
enable_remote_connections

stop_db
echo "DB initialization done."
